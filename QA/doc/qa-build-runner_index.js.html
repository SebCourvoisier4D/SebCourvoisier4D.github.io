<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: qa-build-runner/index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: qa-build-runner/index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

/** 
 * @module BuildRunner 
 * @description The BuildRunner module is dedicated to run the applications to which the tests will be applied (Wakanda Server, Wakanda Studio, 4D Server if needed). This module requires the modules {@link https://github.com/jprichardson/node-fs-extra}, {@link https://nodejs.org/api/path.html}, {@link https://nodejs.org/api/os.html}, {@link https://github.com/caolan/async}, {@link https://github.com/isaacs/node-glob}, {@link https://github.com/request/request}, {@link https://github.com/arturadib/shelljs}, {@link https://github.com/neekey/ps} and {@link https://github.com/sitegui/nodejs-websocket}
 * @requires module:Config
 * @requires module:SeleniumProxy
 * @requires fs-extra
 * @requires path
 * @requires os
 * @requires async
 * @requires glob
 * @requires request
 * @requires shelljs
 * @requires ps-node
 * @requires child_process
 * @requires nodejs-websocket
 */
var fs = require('fs-extra'),
    path = require('path'),
    os = require('os'),
    sh = require('shelljs'),
    Config = require('../qa-config'),
    config = new Config(),
    async = require('async'),
    request = require('request'),
    ps = require('ps-node'),
    glob = require('glob'),
    ChildProcess = require('child_process'),
    ws = require('nodejs-websocket'),
    seleniumProxy = require('../qa-selenium-proxy'),
    serverRunningTimeout,
    studioRunningTimeout,
    BuildRunner = function() {};

BuildRunner.prototype = Object.create(require('events').EventEmitter.prototype);

/** 
 * @function module:BuildRunner.setTimeout
 * @description Set the base timeout used by the BuildRunner module when running the applications
 * @param {number} timeout - Timeout in milliseconds (`2 * 60 * 1000` by default)
 * @throws {TypeError} timeout argument must be a number
 * @returns {module:BuildRunner}
 */
BuildRunner.prototype.setTimeout = function(timeout) {
    if (typeof timeout !== 'number') {
        throw new TypeError('timeout argument must be a number');
    }
    this.priv_timeout = timeout;

    return this;
};

/** 
 * @function module:BuildRunner.getCLITimeoutMultiplier
 * @description Get the timeout multiplier used by the BuildRunner module when running the applications **in CLI mode**  (`5` by default)
 * @returns {number}
 */
BuildRunner.prototype.getCLITimeoutMultiplier = function() {
    if (this.priv_cli_timeout_multiplier === undefined) {
        this.priv_cli_timeout_multiplier = 5;
    }

    return this.priv_cli_timeout_multiplier;
};

/** 
 * @function module:BuildRunner.setCLITimeoutMultiplier
 * @description Set the timeout multiplier used by the BuildRunner module when running the applications **in CLI mode**
 * @param {number} multiplier - Multiplier
 * @throws {TypeError} multiplier argument must be a number
 * @returns {module:BuildRunner}
 */
BuildRunner.prototype.setCLITimeoutMultiplier = function(multiplier) {
    if (typeof multiplier !== 'number') {
        throw new TypeError('multiplier argument must be a number');
    }
    this.priv_cli_timeout_multiplier = multiplier;

    return this;
};

/** 
 * @function module:BuildRunner.getStudioTimeoutMultiplier
 * @description Get the timeout multiplier used by the BuildRunner module when running Wakanda Studio  (`5` by default)
 * @returns {number}
 */
BuildRunner.prototype.getStudioTimeoutMultiplier = function() {
    if (this.priv_studio_timeout_multiplier === undefined) {
        this.priv_studio_timeout_multiplier = 5;
    }

    return this.priv_studio_timeout_multiplier;
};

/** 
 * @function module:BuildRunner.setStudioTimeoutMultiplier
 * @description Set the timeout multiplier used by the BuildRunner module when running Wakanda Studio
 * @param {number} multiplier - Multiplier
 * @throws {TypeError} multiplier argument must be a number
 * @returns {module:BuildRunner}
 */
BuildRunner.prototype.setStudioTimeoutMultiplier = function(multiplier) {
    if (typeof multiplier !== 'number') {
        throw new TypeError('multiplier argument must be a number');
    }
    this.priv_studio_timeout_multiplier = multiplier;

    return this;
};

/** 
 * @function module:BuildRunner.getTimeout
 * @description Get the base timeout used by the BuildRunner module when running the applications
 * @returns {number}
 */
BuildRunner.prototype.getTimeout = function() {
    if (this.priv_timeout === undefined) {
        this.priv_timeout = 2 * 60 * 1000;
    }

    return this.priv_timeout;
};

/** 
 * @function resolveCommand
 * @description Return the full command required to run the given application
 * @param {string} command - The application to run (`"wakanda server"`, `"wakanda studio"`, `"wakanda shell"`, `"wakanda controller"` or `"4d server"`)
 * @param {string} branch - The branch to use
 * @param {number} changelist - The changelist to use
 * @returns {string}
 */
function resolveCommand(command, branch, changelist) {
    if (global.qaConfig === undefined || global.qaConfig.buildsDir === undefined) {
        throw new Error('configuration not loaded or incomplete');
    }
    var commandPath = path.join(global.qaConfig.buildsDir, branch.toLowerCase(), changelist.toString());
    switch (command.toLowerCase()) {
        case 'wakanda server':
            if (config.isWindows()) {
                commandPath = path.join(commandPath, 'Wakanda Enterprise Server', 'Wakanda Server.exe');
            } else if (config.isMac()) {
                commandPath = path.join(commandPath, 'Wakanda Enterprise Server.app', 'Contents', 'MacOS', 'Wakanda Enterprise Server');
            } else {
                commandPath = path.join(commandPath, 'wakanda-enterprise-server', 'bin', 'wakanda-enterprise-server');
            }
            break;
        case 'wakanda studio':
            if (config.isWindows()) {
                commandPath = path.join(commandPath, 'Wakanda Enterprise Studio', 'Wakanda Studio.exe');
            } else if (config.isMac()) {
                commandPath = path.join(commandPath, 'Wakanda Enterprise Studio.app', 'Contents', 'MacOS', 'Wakanda Enterprise Studio');
            } else {
                commandPath = null;
            }
            break;
        case '4d server':
            if (config.isWindows()) {
                commandPath = path.join(commandPath, '4D Server', '4D Server.exe');
            } else if (config.isMac()) {
                commandPath = path.join(commandPath, '4D Server.app', 'Contents', 'MacOS', '4D Server');
            } else {
                commandPath = null;
            }
            break;
        case 'wakanda controller':
            if (config.isWindows()) {
                commandPath = path.join(commandPath, 'Wakanda Controller', 'Wakanda Controller.exe');
            } else {
                commandPath = null;
            }
            break;
        case 'wakanda shell':
            if (config.isWindows()) {
                commandPath = null;
            } else {
                commandPath = path.join(commandPath, 'wakanda');
            }
            break;
        default:
            commandPath = null;
            break;
    }

    return commandPath;
}

/** 
 * @function module:BuildRunner.getCurrentWakandaServerPath
 * @description Get the full path of the current Wakanda Server application
 * @returns {string}
 */
BuildRunner.prototype.getCurrentWakandaServerPath = function() {
    return resolveCommand('wakanda server', config.getCurrentWakandaBranch(), config.getCurrentChangelist());
};

/** 
 * @function module:BuildRunner.getCurrentWakandaStudioPath
 * @description Get the full path of the current Wakanda Studio application
 * @returns {string}
 */
BuildRunner.prototype.getCurrentWakandaStudioPath = function() {
    return resolveCommand('wakanda studio', config.getCurrentWakandaBranch(), config.getCurrentChangelist());
};

/** 
 * @function module:BuildRunner.getCurrent4DServerPath
 * @description Get the full path of the current 4D Server application
 * @returns {string}
 */
BuildRunner.prototype.getCurrent4DServerPath = function() {
    return resolveCommand('4d server', config.getCurrentWakandaBranch(), config.getCurrentChangelist());
};

/** 
 * @function module:BuildRunner.getCurrentWakandaControllerPath
 * @description Get the full path of the current Wakanda Controller application
 * @returns {string}
 */
BuildRunner.prototype.getCurrentWakandaControllerPath = function() {
    return resolveCommand('wakanda controller', config.getCurrentWakandaBranch(), config.getCurrentChangelist());
};

/** 
 * @function module:BuildRunner.getCurrentWakandaShellPath
 * @description Get the full path of the current Wakanda Shell application
 * @returns {string}
 */
BuildRunner.prototype.getCurrentWakandaShellPath = function() {
    return resolveCommand('wakanda shell', config.getCurrentWakandaBranch(), config.getCurrentChangelist());
};

/** 
 * @function module:BuildRunner.startSeleniumProxy
 * @description Start the proxy for Selenium tests
 * @param {object} testConfig - Configuration of the current test
 * @param {string} destination - Root path of the optional virtual folders
 * @param {module:BuildRunner~startSeleniumProxyCallback} cb - Optional callback
 * @returns {module:BuildRunner}
 * @throws {TypeError} testConfig argument must be an object
 * @throws {TypeError} destination argument must be a string
 * @throws {TypeError} cb argument must be a function
 * @fires module:BuildRunner#selenium proxy started
 * @fires module:BuildRunner#selenium proxy not started
 */
/**
 * @callback module:BuildRunner~startSeleniumProxyCallback
 * @param {object} error - Error returned by the method
 */
/**
 * Success event
 *
 * @event module:BuildRunner#selenium proxy started
 * @type {object}
 */
/**
 * Failure event
 *
 * @event module:BuildRunner#selenium proxy not started
 * @type {object}
 * @property {object} error - The error
 */
BuildRunner.prototype.startSeleniumProxy = function(testConfig, destination, cb) {
    if (typeof testConfig !== 'object' || !testConfig) {
        throw new TypeError('testConfig argument must be an object');
    }
    if (typeof destination !== 'string' || !destination) {
        throw new TypeError('destination argument must be a string');
    }
    if (cb !== undefined &amp;&amp; typeof cb !== 'function') {
        throw new TypeError('cb argument must be a function');
    }
    seleniumProxy.start(this, testConfig, destination, cb);

    return this;
};

/** 
 * @function module:BuildRunner.stopSeleniumProxy
 * @param {module:BuildRunner~stopSeleniumProxyCallback} cb - Optional callback
 * @returns {module:BuildRunner}
 * @description Stop the proxy
 * @fires module:BuildRunner#selenium proxy stopped
 * @fires module:BuildRunner#selenium proxy not stopped
 */
/**
 * @callback module:BuildRunner~stopSeleniumProxyCallback
 * @param {object} error - Error returned by the method
 */
/**
 * Success event
 *
 * @event module:BuildRunner#selenium proxy stopped
 * @type {object}
 */
/**
 * Failure event
 *
 * @event module:BuildRunner#selenium proxy not stopped
 * @type {object}
 * @property {object} error - The error
 */
BuildRunner.prototype.stopSeleniumProxy = function(cb) {
    if (cb !== undefined &amp;&amp; typeof cb !== 'function') {
        throw new TypeError('cb argument must be a function');
    }
    seleniumProxy.stop(this, cb);

    return this;
};

/** 
 * @function module:BuildRunner.startWakandaServerCLI
 * @description Start Wakanda Server in CLI mode with the given script
 * @param {number} changelist - Changelist of the build
 * @param {string} script - Full path of the JS script to run
 * @param {boolean} stable - If `true` then a "stable" build (located by the `"cli"` property of the config file) will be used instead of the current one (default to `false`)
 * @param {module:BuildRunner~startWakandaServerCLICallback} cb - Optional callback
 * @returns {module:BuildRunner}
 * @throws {TypeError} changelist argument must be a number
 * @throws {TypeError} script argument must be a string
 * @throws {TypeError} stable argument must be a boolean
 * @throws {TypeError} cb argument must be a function
 * @fires module:BuildRunner#wakanda cli started
 * @fires module:BuildRunner#wakanda cli not started
 * @fires module:BuildRunner#wakanda cli stdout
 * @fires module:BuildRunner#wakanda cli stderr
 * @fires module:BuildRunner#wakanda cli stopped
 */
/**
 * @callback module:BuildRunner~startWakandaServerCLICallback
 * @param {object} error - Error returned by the method
 */
/**
 * Success event
 *
 * @event module:BuildRunner#wakanda cli started
 * @type {object}
 */
/**
 * Failure event
 *
 * @event module:BuildRunner#wakanda cli not started
 * @type {object}
 * @property {object} error - The error
 */
/**
 * STDOUT event
 *
 * @event module:BuildRunner#wakanda cli stdout
 * @type {object}
 * @property {string} data - STDOUT data
 */
/**
 * STDERR event
 *
 * @event module:BuildRunner#wakanda cli stderr
 * @type {object}
 * @property {string} data - STDERR data
 */
/**
 * Stop event
 *
 * @event module:BuildRunner#wakanda cli stopped
 * @type {object}
 */
BuildRunner.prototype.startWakandaServerCLI = function(changelist, script, stable, cb) {
    if (typeof changelist !== 'number') {
        throw new TypeError('changelist argument must be a number');
    }
    if (typeof script !== 'string') {
        throw new TypeError('script argument must be a string');
    }
    if (stable === undefined) {
        stable = false;
    }
    if (cb === undefined &amp;&amp; stable !== undefined &amp;&amp; typeof stable === 'function') {
        cb = stable;
        stable = false;
    }
    if (stable !== undefined &amp;&amp; typeof stable !== 'boolean') {
        throw new TypeError('stable argument must be a boolean');
    }
    if (cb !== undefined &amp;&amp; typeof cb !== 'function') {
        throw new TypeError('cb argument must be a function');
    }

    var self = this,
        command = '',
        serverProcess;

    clearTimeout(serverRunningTimeout);
    if (!sh.test('-f', script)) {
        if (typeof cb === 'function') {
            cb('script not found');
        } else {
            self.emit('wakanda cli not started', 'script not found', changelist, script);
        }
    } else {
        self.killByName('wakanda server', true, function(err) {
            if (!err || err === 'process not found') {
                if (stable === false) {
                    command = resolveCommand('wakanda server', config.getCurrentWakandaBranch(), changelist);
                } else if (global.qaConfig &amp;&amp; global.qaConfig.cli) {
                    command = global.qaConfig.cli;
                }
                try {
                    if (config.isDebug() === false) {
                        serverProcess = ChildProcess.spawn(command, ['--debug-off', script], {
                            env: config.buildEnvironment()
                        });
                    } else {
                        serverProcess = ChildProcess.spawn(command, [script], {
                            env: config.buildEnvironment()
                        });
                    }
                    serverProcess.once('error', function(e) {
                        clearTimeout(serverRunningTimeout);
                        if (typeof cb === 'function') {
                            cb(e);
                        } else {
                            self.emit('wakanda cli not started', e, changelist, script);
                        }
                    });
                    serverProcess.stdout.once('data', function(data) {
                        if (typeof cb === 'function') {
                            cb(null, serverProcess);
                        } else {
                            self.emit('wakanda cli started', data, serverProcess, changelist, script);
                        }
                        data = data.toString().trim();
                        self.emit('wakanda cli stdout', data, serverProcess, changelist, script);
                        clearTimeout(serverRunningTimeout);
                        serverRunningTimeout = setTimeout(function(self) {
                            self.stopWakandaServerCLI('timeout');
                        }, self.getTimeout() * self.getCLITimeoutMultiplier(), self);
                        serverProcess.stdout.on('data', function(data) {
                            data = data.toString().trim();
                            self.emit('wakanda cli stdout', data, serverProcess, changelist, script);
                            clearTimeout(serverRunningTimeout);
                            serverRunningTimeout = setTimeout(function(self) {
                                self.stopWakandaServerCLI('timeout');
                            }, self.getTimeout() * self.getCLITimeoutMultiplier(), self);
                        });
                    });
                    serverProcess.stderr.on('data', function(data) {
                        self.emit('wakanda cli stderr', data.toString().trim(), serverProcess, changelist, script);
                        clearTimeout(serverRunningTimeout);
                        serverRunningTimeout = setTimeout(function(self) {
                            self.stopWakandaServerCLI('timeout');
                        }, self.getTimeout() * self.getCLITimeoutMultiplier(), self);
                    });
                    serverProcess.once('exit', function(code) {
                        clearTimeout(serverRunningTimeout);
                        self.emit('wakanda cli stopped', null, code.toString(), changelist, script);
                    });
                } catch (e) {
                    clearTimeout(serverRunningTimeout);
                    if (typeof cb === 'function') {
                        cb(e);
                    } else {
                        self.emit('wakanda cli not started', e, changelist, script);
                    }
                }
            } else {
                if (typeof cb === 'function') {
                    cb(err);
                } else {
                    self.emit('wakanda cli not started', err, changelist, script);
                }
            }
        });
    }

    return this;
};

/** 
 * @function tryToConnectToServer
 * @description Once a Wakanda Server has been started **by the BuildRunner itself**, this function tries to reach it through the `ws://127.0.0.1:8080/remote_admin_ws/` socket
 * @param {module:BuildRunner} self - The current module:BuildRunner instance
 * @param {object} serverProcess - The current Wakanda Server process (as returned by the `ChildProcess.spawn()` method)
 * @param {number} changelist - Current changelist
 * @param {module:BuildRunner~tryToConnectToServerCallback} cb - Optional callback
 * @param {number} tries - Number of tries (max `60`)
 * @fires module:BuildRunner#wakanda server started
 * @fires module:BuildRunner#wakanda server not started
 * @fires module:BuildRunner#wakanda server event
 */
/**
 * @callback module:BuildRunner~tryToConnectToServerCallback
 * @param {object} error - Error returned by the method
 */
/**
 * Success event
 *
 * @event module:BuildRunner#wakanda server started
 * @type {object}
 */
/**
 * Failure event
 *
 * @event module:BuildRunner#wakanda server not started
 * @type {object}
 * @property {object} error - The error
 */
/**
 * WebSocket event
 *
 * @event module:BuildRunner#wakanda server event
 * @type {object}
 * @property {string} data - WebSocket data
 * @property {object} client - WebSocket client
 */
function tryToConnectToServer(self, serverProcess, changelist, cb, tries) {
    if (tries &lt; 60) {
        var clientWS = ws.connect('ws://127.0.0.1:8080/remote_admin_ws/', {
            rejectUnauthorized: false
        });
        clientWS.once('text', function(data) {
            self.reconductWakandaServerTimeout('remote_admin_ws');
            if (typeof cb === 'function') {
                cb(null, data, clientWS, serverProcess);
            } else {
                self.emit('wakanda server started', data, clientWS, serverProcess, changelist);
            }
            clientWS.on('text', function(data) {
                self.reconductWakandaServerTimeout('remote_admin_ws');
                try {
                    data = JSON.parse(data);
                    if (data.message !== undefined &amp;&amp; data.message === 'solution opened') {
                        self.emit('wakanda server event', {
                            event: data.message,
                            data: data
                        }, clientWS, serverProcess, changelist);
                    } else {
                        self.emit('wakanda server event', data, clientWS, serverProcess, changelist);
                    }
                } catch (ignore) {
                    self.emit('wakanda server event', {
                        data: data
                    }, clientWS, serverProcess, changelist);
                }
            });
        });
        clientWS.once('error', function() {
            setTimeout(tryToConnectToServer, 500, self, serverProcess, changelist, cb, tries + 1);
        });
    } else {
        if (typeof cb === 'function') {
            cb('wakanda server is unreachable', serverProcess);
        } else {
            self.emit('wakanda server not started', 'wakanda server is unreachable', serverProcess);
        }
    }
}

/** 
 * @function module:BuildRunner.catchWakandaServer
 * @description Once a Wakanda Server has been started **by another process**, this function tries to reach it through the `ws://127.0.0.1:8080/remote_admin_ws/` socket
 * @param {module:BuildRunner~catchWakandaServerCallback} cb - Optional callback
 * @param {number} tries - Number of tries (max `60`)
 * @returns {module:BuildRunner}
 */
/**
 * @callback module:BuildRunner~catchWakandaServerCallback
 * @param {object} error - Error returned by the method
 */
BuildRunner.prototype.catchWakandaServer = function(cb, tries) {
    if (cb !== undefined &amp;&amp; typeof cb !== 'function') {
        throw new TypeError('cb argument must be a function');
    }
    if (tries === undefined) {
        tries = 0;
    }

    var self = this;

    if (tries &lt; 60) {
        var clientWS = ws.connect('ws://127.0.0.1:8080/remote_admin_ws/', {
            rejectUnauthorized: false
        });
        clientWS.once('text', function(data) {
            if (typeof cb === 'function') {
                cb(null, data, clientWS);
            } else {
                self.emit('wakanda server started', data, clientWS);
            }
            clientWS.on('text', function(data) {
                try {
                    data = JSON.parse(data);
                    if (data.message !== undefined &amp;&amp; data.message === 'solution opened') {
                        self.emit('wakanda server event', {
                            event: data.message,
                            data: data
                        }, clientWS);
                    } else {
                        self.emit('wakanda server event', data, clientWS);
                    }
                } catch (ignore) {
                    self.emit('wakanda server event', {
                        data: data
                    }, clientWS);
                }
            });
        });
        clientWS.once('error', function() {
            setTimeout(function(_self, _cb, _tries) {
                _self.catchWakandaServer(_cb, _tries);
            }, 500, self, cb, tries + 1);
        });
    } else {
        if (typeof cb === 'function') {
            cb('wakanda server is unreachable');
        } else {
            self.emit('wakanda server not started', 'wakanda server is unreachable');
        }
    }

    return self;
};

/** 
 * @function module:BuildRunner.sendCommandToWakandaServer
 * @description Send a command to the running instance of Wakanda Server. If the `clientWS` optional parameter is given, then the command will be sent using the Admin WebSocket interface (not implemented on the Server-side...). By default, the command is sent using the JSON-RPC interface.
 * @param {string} command - The command to run
 * @param {Array} args - The arguments for the given command
 * @param {object} clientWS - optional WebSocket client (as returned by the `wakanda server started` or `wakanda server event` events)
 * @param {module:BuildRunner~sendCommandToWakandaServerCallback} cb - Optional callback
 * @returns {module:BuildRunner}
 * @fires module:BuildRunner#wakanda server command sent
 * @fires module:BuildRunner#wakanda server command not sent
 */
/**
 * @callback module:BuildRunner~sendCommandToWakandaServerCallback
 * @param {object} error - Error returned by the method
 */
/**
 * Success event
 *
 * @event module:BuildRunner#wakanda server command sent
 * @type {object}
 */
/**
 * Failure event
 *
 * @event module:BuildRunner#wakanda server command not sent
 * @type {object}
 * @property {object} error - The error
 */
BuildRunner.prototype.sendCommandToWakandaServer = function(command, args, clientWS, cb) {
    if (typeof command !== 'string') {
        throw new TypeError('command argument must be a string');
    }
    if (args instanceof Array === false) {
        throw new TypeError('args argument must be an Array');
    }
    if (typeof clientWS === 'function' || cb === undefined) {
        cb = clientWS;
        clientWS = undefined;
    }
    if (clientWS !== undefined &amp;&amp; (typeof clientWS !== 'object' || typeof clientWS.sendText !== 'function')) {
        throw new TypeError('clientWS argument must be a valid WebSocket connection');
    }
    if (cb !== undefined &amp;&amp; typeof cb !== 'function') {
        throw new TypeError('cb argument must be a function');
    }

    var self = this,
        now = new Date();

    if (clientWS !== undefined) {
        clientWS.sendText(JSON.stringify({
            command: command,
            args: args
        }), function(err) {
            if (err) {
                if (typeof cb === 'function') {
                    cb(err);
                } else {
                    self.emit('wakanda server command not sent', err, command, args, clientWS);
                }
            } else {
                if (typeof cb === 'function') {
                    cb(null);
                } else {
                    self.emit('wakanda server command sent', null, command, args, clientWS);
                }
            }
        });
    } else {
        request({
            method: 'POST',
            url: 'http://127.0.0.1:8080/rpc/',
            headers: {
                'Connection': 'close',
                'Content-type': 'application/json-rpc; charset=utf-8',
                'Accept': 'application/json-rpc',
                'Accept-Encoding': 'gzip,deflate'
            },
            body: '{"jsonrpc":"2.0","id":' + now.getTime() + ',"module":"admin","method":"' + command + '","params":"' + (args.length > 1 ? JSON.stringify(args) : args[0]) + '"}'
        }, function(err, response, data) {
            if (err) {
                if (typeof cb === 'function') {
                    cb(err, data);
                } else {
                    self.emit('wakanda server command not sent', err, data, command, args, clientWS);
                }
            } else {
                try {
                    data = JSON.parse(data);
                    if (data.error !== undefined) {
                        if (typeof cb === 'function') {
                            cb(data.error, data);
                        } else {
                            self.emit('wakanda server command not sent', data.error, data, command, args, clientWS);
                        }
                    } else {
                        if (typeof cb === 'function') {
                            cb(null, data);
                        } else {
                            self.emit('wakanda server command sent', null, data, command, args, clientWS);
                        }
                    }
                } catch (e) {
                    if (typeof cb === 'function') {
                        cb(e, data);
                    } else {
                        self.emit('wakanda server command not sent', e, data, command, args, clientWS);
                    }
                }
            }
        });
    }

    return this;
};

/** 
 * @function module:BuildRunner.reconductWakandaServerTimeout
 * @description Force the renewal of Wakanda Server timeout.
 * @returns {module:BuildRunner}
 */
BuildRunner.prototype.reconductWakandaServerTimeout = function(origin) {
    var self = this;

    clearTimeout(serverRunningTimeout);
    serverRunningTimeout = setTimeout(function(self) {
        self.wakandaServerProperlyExited = false;
        self.stopWakandaServer('timeout');
    }, self.getTimeout(), self);

    return this;
};

/** 
 * @function module:BuildRunner.startWakandaServer
 * @description Start a Wakanda Server instance (using the given changelist).
 * @param {number} changelist - The changelist to use
 * @param {module:BuildRunner~startWakandaServerCallback} cb - Optional callback
 * @returns {module:BuildRunner}
 * @fires module:BuildRunner#wakanda server stdout
 * @fires module:BuildRunner#wakanda server stderr
 * @fires module:BuildRunner#wakanda server stopped
 */
/**
 * @callback module:BuildRunner~startWakandaServerCallback
 * @param {object} error - Error returned by the method
 */
/**
 * STDOUT event
 *
 * @event module:BuildRunner#wakanda server stdout
 * @type {object}
 * @property {string} data - STDOUT data
 */
/**
 * STDERR event
 *
 * @event module:BuildRunner#wakanda server stderr
 * @type {object}
 * @property {string} data - STDERR data
 */
/**
 * Stop event
 *
 * @event module:BuildRunner#wakanda server stopped
 * @type {object}
 */
BuildRunner.prototype.startWakandaServer = function(changelist, cb) {
    if (typeof changelist !== 'number') {
        throw new TypeError('changelist argument must be a number');
    }
    if (cb !== undefined &amp;&amp; typeof cb !== 'function') {
        throw new TypeError('cb argument must be a function');
    }

    var self = this,
        command,
        serverProcess;

    clearTimeout(serverRunningTimeout);
    self.wakandaServerProperlyExited = true;
    self.killByName('wakanda server', true, function(err) {
        if (!err || err === 'process not found') {
            command = resolveCommand('wakanda server', config.getCurrentWakandaBranch(), changelist);
            try {
                if (config.isDebug() === false) {
                    serverProcess = ChildProcess.spawn(command, ['--debug-off'], {
                        env: config.buildEnvironment()
                    });
                } else {
                    serverProcess = ChildProcess.spawn(command, [], {
                        env: config.buildEnvironment()
                    });
                }
                serverProcess.on('error', function(e) {
                    clearTimeout(serverRunningTimeout);
                    if (typeof cb === 'function') {
                        cb(e);
                    } else {
                        self.emit('wakanda server not started', e, changelist);
                    }
                });
                serverProcess.stdout.on('data', function(data) {
                    self.emit('wakanda server stdout', data.toString().trim(), serverProcess, changelist);
                    self.reconductWakandaServerTimeout('STDOUT');
                });
                serverProcess.stderr.on('data', function(data) {
                    self.emit('wakanda server stderr', data.toString().trim(), serverProcess, changelist);
                    self.reconductWakandaServerTimeout('STDERR');
                });
                serverProcess.once('exit', function(code) {
                    if (self.wakandaServerProperlyExited === true) {
                        self.emit('wakanda server stopped', null, code ? code.toString() : null, changelist);
                    }
                });
                tryToConnectToServer(self, serverProcess, changelist, cb, 0);
            } catch (e) {
                clearTimeout(serverRunningTimeout);
                if (typeof cb === 'function') {
                    cb(e);
                } else {
                    self.emit('wakanda server not started', e, changelist);
                }
            }
        } else {
            if (typeof cb === 'function') {
                cb(err);
            } else {
                self.emit('wakanda server not started', err, changelist);
            }
        }
    });

    return this;
};

/** @ignore */
function tryToFindTheStudio(self, studioProcess, changelist, cb, tries) {
    if (tries &lt; 60) {
        self.getInfoByName('wakanda studio', function(err, data) {
            if (err) {
                setTimeout(tryToFindTheStudio, 500, self, studioProcess, changelist, cb, tries + 1);
            } else {
                setTimeout(function(self, studioProcess, changelist, cb, data) {
                    if (typeof cb === 'function') {
                        cb(null, data, studioProcess);
                    } else {
                        self.emit('wakanda studio started', data, studioProcess, changelist);
                    }
                }, 5000, self, studioProcess, changelist, cb, data); // must wait a bit: about 5 seconds between the launch of the process and the launch of the UI...
            }
        });
    } else {
        if (typeof cb === 'function') {
            cb('wakanda studio is unreachable', studioProcess);
        } else {
            self.emit('wakanda studio not started', 'wakanda studio is unreachable', studioProcess);
        }
    }
}

/** 
 * @function tryToConnectToStudio
 * @description Once a Wakanda Studio has been started **by the BuildRunner itself**, this function tries to reach it through the `ws://127.0.0.1:8079/` socket **opened by the UnitTest Monitor** (experimental)
 * @param {module:BuildRunner} self - The current module:BuildRunner instance
 * @param {object} studioProcess - The current Wakanda Studio process (as returned by the `ChildProcess.spawn()` method)
 * @param {number} changelist - Current changelist
 * @param {module:BuildRunner~tryToConnectToStudioCallback} cb - Optional callback
 * @param {number} tries - Number of tries (max `60`)
 * @fires module:BuildRunner#wakanda studio started
 * @fires module:BuildRunner#wakanda studio not started
 * @fires module:BuildRunner#wakanda studio event
 */
/**
 * @callback module:BuildRunner~tryToConnectToStudioCallback
 * @param {object} error - Error returned by the method
 */
/**
 * Success event
 *
 * @event module:BuildRunner#wakanda studio started
 * @type {object}
 */
/**
 * Failure event
 *
 * @event module:BuildRunner#wakanda studio not started
 * @type {object}
 * @property {object} error - The error
 */
/**
 * WebSocket event
 *
 * @event module:BuildRunner#wakanda studio event
 * @type {object}
 * @property {string} data - WebSocket data
 * @property {object} client - WebSocket client
 */
function tryToConnectToStudio(self, studioProcess, changelist, cb, tries) {
    if (tries &lt; 60) {
        var clientWS = ws.connect('ws://127.0.0.1:8079/', {
            rejectUnauthorized: false
        });
        clientWS.once('text', function(data) {
            clearTimeout(studioRunningTimeout);
            studioRunningTimeout = setTimeout(function(self) {
                self.wakandaStudioProperlyExited = false;
                self.stopWakandaStudio('timeout');
            }, self.getTimeout() * self.getStudioTimeoutMultiplier(), self);
            if (typeof cb === 'function') {
                cb(null, data, clientWS, studioProcess);
            } else {
                self.emit('wakanda studio started', data, clientWS, studioProcess, changelist);
            }
            clientWS.on('text', function(data) {
                clearTimeout(studioRunningTimeout);
                if (typeof data === 'object') {
                    self.emit('wakanda studio event', data, clientWS, studioProcess, changelist);
                } else {
                    try {
                        data = JSON.parse(data.toString());
                        self.emit('wakanda studio event', data, clientWS, studioProcess, changelist);
                    } catch (e) {
                        self.emit('wakanda studio event', {
                            data: data
                        }, clientWS, studioProcess, changelist);
                    }
                }
            });
        });
        clientWS.once('error', function() {
            setTimeout(tryToConnectToStudio, 500, self, studioProcess, changelist, cb, tries + 1);
        });
    } else {
        clearTimeout(studioRunningTimeout);
        if (typeof cb === 'function') {
            cb('wakanda studio is unreachable', studioProcess);
        } else {
            self.emit('wakanda studio not started', 'wakanda studio is unreachable', studioProcess);
        }
    }
}

/** 
 * @function module:BuildRunner.sendCommandToWakandaStudio
 * @description Send a command to the running instance of Wakanda Studio **using the WebSocket interface of the UnitTest Monitor** (experimental).
 * @param {string} command - The command to run
 * @param {Array} args - The arguments for the given command
 * @param {object} clientWS - Optional WebSocket client (as returned by the `wakanda server started` or `wakanda server event` events)
 * @param {module:BuildRunner~sendCommandToWakandaStudioCallback} cb - Optional callback
 * @returns {module:BuildRunner}
 * @fires module:BuildRunner#wakanda studio command sent
 * @fires module:BuildRunner#wakanda studio command not sent
 */
/**
 * @callback module:BuildRunner~sendCommandToWakandaStudioCallback
 * @param {object} error - Error returned by the method
 */
/**
 * Success event
 *
 * @event module:BuildRunner#wakanda studio command sent
 * @type {object}
 */
/**
 * Failure event
 *
 * @event module:BuildRunner#wakanda studio command not sent
 * @type {object}
 * @property {object} error - The error
 */
BuildRunner.prototype.sendCommandToWakandaStudio = function(command, args, clientWS, cb) {
    if (typeof command !== 'string') {
        throw new TypeError('command argument must be a string');
    }
    if (args instanceof Array === false) {
        throw new TypeError('args argument must be an Array');
    }
    if (typeof clientWS !== 'object' || typeof clientWS.sendText !== 'function') {
        throw new TypeError('clientWS argument must be a valid WebSocket connection');
    }
    if (cb !== undefined &amp;&amp; typeof cb !== 'function') {
        throw new TypeError('cb argument must be a function');
    }

    var self = this;

    clientWS.sendText(JSON.stringify({
        command: command,
        args: args
    }), function(err) {
        if (err) {
            if (typeof cb === 'function') {
                cb(err);
            } else {
                self.emit('wakanda studio command not sent', err, command, args, clientWS);
            }
        } else {
            if (typeof cb === 'function') {
                cb(null);
            } else {
                self.emit('wakanda studio command sent', null, command, args, clientWS);
            }
        }
    });

    return this;
};

/** 
 * @function module:BuildRunner.startWakandaStudio
 * @description Start a Wakanda Studio instance (using the given changelist).
 * @param {number} changelist - The changelist to use
 * @param {module:BuildRunner~startWakandaStudioCallback} cb - Optional callback
 * @returns {module:BuildRunner}
 * @fires module:BuildRunner#wakanda server stdout
 * @fires module:BuildRunner#wakanda server stderr
 */
/**
 * @callback module:BuildRunner~startWakandaStudioCallback
 * @param {object} error - Error returned by the method
 */
/**
 * STDOUT event
 *
 * @event module:BuildRunner#wakanda studio stdout
 * @type {object}
 * @property {string} data - STDOUT data
 */
/**
 * STDERR event
 *
 * @event module:BuildRunner#wakanda studio stderr
 * @type {object}
 * @property {string} data - STDERR data
 */
/**
 * Stop event
 *
 * @event module:BuildRunner#wakanda studio stopped
 * @type {object}
 */
BuildRunner.prototype.startWakandaStudio = function(changelist, cb) {
    if (typeof changelist !== 'number') {
        throw new TypeError('changelist argument must be a number');
    }
    if (cb !== undefined &amp;&amp; typeof cb !== 'function') {
        throw new TypeError('cb argument must be a function');
    }

    var self = this,
        command,
        studioProcess;

    clearTimeout(studioRunningTimeout);
    self.wakandaStudioProperlyExited = true;
    self.killByName('wakanda studio', true, function(err) {
        if (!err || err === 'process not found') {
            command = resolveCommand('wakanda studio', config.getCurrentWakandaBranch(), changelist);
            try {
                studioProcess = ChildProcess.spawn(command, [], {
                    env: config.buildEnvironment()
                });
                studioProcess.on('error', function(e) {
                    if (typeof cb === 'function') {
                        cb(e);
                    } else {
                        self.emit('wakanda studio not started', e, changelist);
                    }
                });
                studioProcess.stdout.on('data', function(data) {
                    self.emit('wakanda studio stdout', data.toString().trim(), studioProcess, changelist);
                    clearTimeout(studioRunningTimeout);
                    studioRunningTimeout = setTimeout(function(self) {
                        self.wakandaStudioProperlyExited = false;
                        self.stopWakandaStudio('timeout');
                    }, self.getTimeout() * self.getStudioTimeoutMultiplier(), self);
                });
                studioProcess.stderr.on('data', function(data) {
                    self.emit('wakanda studio stderr', data.toString().trim(), studioProcess, changelist);
                    clearTimeout(studioRunningTimeout);
                    studioRunningTimeout = setTimeout(function(self) {
                        self.wakandaStudioProperlyExited = false;
                        self.stopWakandaStudio('timeout');
                    }, self.getTimeout() * self.getStudioTimeoutMultiplier(), self);
                });
                studioProcess.once('exit', function(code) {
                    if (self.wakandaStudioProperlyExited === true) {
                        self.emit('wakanda studio stopped', null, code.toString(), changelist);
                    }
                });
                tryToConnectToStudio(self, studioProcess, changelist, cb, 0);
            } catch (e) {
                clearTimeout(studioRunningTimeout);
                if (typeof cb === 'function') {
                    cb(e);
                } else {
                    self.emit('wakanda studio not started', e, changelist);
                }
            }
        } else {
            if (typeof cb === 'function') {
                cb(err);
            } else {
                self.emit('wakanda studio not started', err, changelist);
            }
        }
    });

    return this;
};

/** 
 * @function tryToFind4DServer
 * @description Once a 4D Server has been started **by the BuildRunner itself**, this function ensures that its process is actually running
 * @param {module:BuildRunner} self - The current module:BuildRunner instance
 * @param {object} fourdProcess - The current 4D Server process (as returned by the `ChildProcess.spawn()` method)
 * @param {number} changelist - Current changelist
 * @param {string} base - Path to the 4D base
 * @param {module:BuildRunner~tryToFind4DServerCallback} cb - Optional callback
 * @param {number} tries - Number of tries (max `60`)
 * @fires module:BuildRunner#4d server started
 * @fires module:BuildRunner#4d server not started
 */
/**
 * @callback module:BuildRunner~tryToFind4DServerCallback
 * @param {object} error - Error returned by the method
 */
/**
 * Success event
 *
 * @event module:BuildRunner#4d server started
 * @type {object}
 */
/**
 * Failure event
 *
 * @event module:BuildRunner#4d server not started
 * @type {object}
 * @property {object} error - The error
 */
function tryToFind4DServer(self, fourdProcess, changelist, base, cb, tries) {
    if (tries &lt; 60) {
        self.getInfoByName('4d server', function(err, data) {
            if (err) {
                setTimeout(tryToFind4DServer, 500, self, fourdProcess, changelist, base, cb, tries + 1);
            } else {
                setTimeout(function(self, fourdProcess, changelist, base, cb, data) {
                    if (typeof cb === 'function') {
                        cb(null, data, fourdProcess);
                    } else {
                        self.emit('4d server started', data, fourdProcess, changelist, base);
                    }
                }, 10 * 1000, self, fourdProcess, changelist, base, cb, data); // must wait a bit: like 10 seconds between the launch of the process and the launch of the UI...
            }
        });
    } else {
        if (typeof cb === 'function') {
            cb('4d server is unreachable', fourdProcess);
        } else {
            self.emit('4d server not started', '4d server is unreachable', fourdProcess, changelist, base);
        }
    }
}

/** 
 * @function module:BuildRunner.check4DServerReady
 * @description Check that the current 4D Server instance is ready by performing a HTTP GET request on the given URL
 * @param {number} tries - Number of tries (max `60`)
 * @param {string} url - URL to check (default to `"http://127.0.0.1:994/"`)
 * @param {string} expected - The expected content to get (default to `"server started"`)
 * @returns {module:BuildRunner}
 * @fires module:BuildRunner#4d server ready
 * @fires module:BuildRunner#4d server not ready
 */
/**
 * Success event
 *
 * @event module:BuildRunner#4d server ready
 * @type {object}
 */
/**
 * Failure event
 *
 * @event module:BuildRunner#4d server not ready
 * @type {object}
 * @property {object} error - The error
 */
BuildRunner.prototype.check4DServerReady = function(tries, url, expected) {
    var self = this;

    if (url === undefined) {
        url = 'http://127.0.0.1:994/';
    }
    if (expected === undefined) {
        expected = 'server started';
    }
    if (tries &lt; 60) {
        request({
            method: 'GET',
            url: url
        }, function(err, response, data) {
            if (err) {
                setTimeout(self.check4DServerReady, 500, tries + 1);
            } else {
                if (data.toString().trim().toLowerCase() === expected) {
                    self.emit('4d server ready');
                } else {
                    self.emit('4d server not ready');
                }
            }
        });
    } else {
        self.emit('4d server not ready');
    }

    return this;
};

/** 
 * @function module:BuildRunner.start4DServer
 * @description Start a 4D Server instance (using the given changelist and 4D base).
 * @param {number} changelist - The changelist to use
 * @param {string} base - The 4D base to use
 * @param {module:BuildRunner~start4DServerCallback} cb - Optional callback
 * @returns {module:BuildRunner}
 * @fires module:BuildRunner#4d server stdout
 * @fires module:BuildRunner#4d server stderr
 * @fires module:BuildRunner#4d server stopped
 */
/**
 * @callback module:BuildRunner~start4DServerCallback
 * @param {object} error - Error returned by the method
 */
/**
 * STDOUT event
 *
 * @event module:BuildRunner#4d server stdout
 * @type {object}
 * @property {string} data - STDOUT data
 */
/**
 * STDERR event
 *
 * @event module:BuildRunner#4d server stderr
 * @type {object}
 * @property {string} data - STDERR data
 */
/**
 * Stop event
 *
 * @event module:BuildRunner#4d server stopped
 * @type {object}
 */
BuildRunner.prototype.start4DServer = function(changelist, base, cb) {
    if (typeof changelist !== 'number') {
        throw new TypeError('changelist argument must be a number');
    }
    if (typeof base !== 'string') {
        throw new TypeError('base argument must be a string');
    }
    if (cb !== undefined &amp;&amp; typeof cb !== 'function') {
        throw new TypeError('cb argument must be a function');
    }

    var self = this,
        command,
        fourdProcess;

    self.killByName('4d server', true, function(err) {
        if (!err || err === 'process not found') {
            command = resolveCommand('4d server', config.getCurrentWakandaBranch(), changelist);
            try {
                fourdProcess = ChildProcess.spawn(command, [base], {
                    env: config.buildEnvironment()
                });
                fourdProcess.on('error', function(e) {
                    if (typeof cb === 'function') {
                        cb(e);
                    } else {
                        self.emit('4d server not started', e, null, changelist, base);
                    }
                });
                fourdProcess.stdout.on('data', function(data) {
                    self.emit('4d server stdout', data.toString().trim(), fourdProcess, changelist, base);
                });
                fourdProcess.stderr.on('data', function(data) {
                    self.emit('4d server stderr', data.toString().trim(), fourdProcess, changelist, base);
                });
                fourdProcess.once('exit', function(code) {
                    self.emit('4d server stopped', code, changelist, base);
                });
                tryToFind4DServer(self, fourdProcess, changelist, base, cb, 0);
            } catch (e) {
                if (typeof cb === 'function') {
                    cb(e);
                } else {
                    self.emit('4d server not started', e, null, changelist, base);
                }
            }
        } else {
            if (typeof cb === 'function') {
                cb(err);
            } else {
                self.emit('4d server not started', err, null, changelist, base);
            }
        }
    });

    return this;
};

/** 
 * @function module:BuildRunner.stopWakandaServerCLI
 * @description Stop the current Wakanda Server instance (running in CLI mode).
 * @param {string} reason - Optional reason for stopping the Server
 * @param {module:BuildRunner~stopWakandaServerCLICallback} cb - Optional callback
 * @returns {module:BuildRunner}
 * @fires module:BuildRunner#wakanda cli not stopped
 */
/**
 * @callback module:BuildRunner~stopWakandaServerCLICallback
 * @param {object} error - Error returned by the method
 */
/**
 * Failure event
 *
 * @event module:BuildRunner#wakanda cli not stopped
 * @type {object}
 * @property {object} error - The error
 */
BuildRunner.prototype.stopWakandaServerCLI = function(reason, cb) {
    clearTimeout(serverRunningTimeout);
    if (typeof reason === 'function' &amp;&amp; cb === undefined) {
        cb = reason;
        reason = undefined;
    }
    if (reason !== undefined &amp;&amp; typeof reason !== 'string') {
        throw new TypeError('reason argument must be a string');
    }
    if (cb !== undefined &amp;&amp; typeof cb !== 'function') {
        throw new TypeError('cb argument must be a function');
    }

    var self = this;

    self.killByName('wakanda server', true, function(err) {
        if (err) {
            if (typeof cb === 'function') {
                cb(err);
            } else {
                self.emit('wakanda cli not stopped', err, reason);
            }
        } else {
            if (typeof cb === 'function') {
                cb(null, reason);
            } else {
                self.emit('wakanda cli stopped', null, reason);
            }
        }
    });

    return this;
};

/** 
 * @function module:BuildRunner.stopWakandaServer
 * @description Stop the current Wakanda Server instance.
 * @param {string} reason - Optional reason for stopping the Server
 * @param {module:BuildRunner~stopWakandaServerCallback} cb - Optional callback
 * @returns {module:BuildRunner}
 * @fires module:BuildRunner#wakanda server not stopped
 */
/**
 * @callback module:BuildRunner~stopWakandaServerCallback
 * @param {object} error - Error returned by the method
 */
/**
 * Failure event
 *
 * @event module:BuildRunner#wakanda server not stopped
 * @type {object}
 * @property {object} error - The error
 */
BuildRunner.prototype.stopWakandaServer = function(reason, cb) {
    clearTimeout(serverRunningTimeout);
    if (typeof reason === 'function' &amp;&amp; cb === undefined) {
        cb = reason;
        reason = undefined;
    }
    if (reason !== undefined &amp;&amp; typeof reason !== 'string') {
        throw new TypeError('reason argument must be a string');
    }
    if (cb !== undefined &amp;&amp; typeof cb !== 'function') {
        throw new TypeError('cb argument must be a function');
    }

    var self = this;

    self.killByName('wakanda server', true, function(err) {
        if (err) {
            if (typeof cb === 'function') {
                cb(err);
            } else {
                self.emit('wakanda server not stopped', err, reason);
            }
        } else {
            if (typeof cb === 'function') {
                cb(null, reason);
            } else {
                self.emit('wakanda server stopped', null, reason);
            }
        }
    });

    return this;
};

/** 
 * @function module:BuildRunner.stopWakandaStudio
 * @description Stop the current Wakanda Studio instance.
 * @param {string} reason - Optional reason for stopping the Studio
 * @param {module:BuildRunner~stopWakandaStudioCallback} cb - Optional callback
 * @returns {module:BuildRunner}
 * @fires module:BuildRunner#wakanda studio not stopped
 */
/**
 * @callback module:BuildRunner~stopWakandaStudioCallback
 * @param {object} error - Error returned by the method
 */
/**
 * Failure event
 *
 * @event module:BuildRunner#wakanda studio not stopped
 * @type {object}
 * @property {object} error - The error
 */
BuildRunner.prototype.stopWakandaStudio = function(reason, cb) {
    clearTimeout(studioRunningTimeout);
    if (typeof reason === 'function' &amp;&amp; cb === undefined) {
        cb = reason;
        reason = undefined;
    }
    if (reason !== undefined &amp;&amp; typeof reason !== 'string') {
        throw new TypeError('reason argument must be a string');
    }
    if (cb !== undefined &amp;&amp; typeof cb !== 'function') {
        throw new TypeError('cb argument must be a function');
    }

    var self = this;

    self.killByName('wakanda studio', true, function(err) {
        if (err) {
            if (typeof cb === 'function') {
                cb(err);
            } else {
                self.emit('wakanda studio not stopped', err, reason);
            }
        } else {
            if (typeof cb === 'function') {
                cb(null, reason);
            } else {
                self.emit('wakanda studio stopped', null, reason);
            }
        }
    });

    return this;
};

/** 
 * @function module:BuildRunner.stop4DServer
 * @description Stop the current 4D Server instance.
 * @param {string} reason - Optional reason for stopping the 4D Server
 * @param {module:BuildRunner~stop4DServerCallback} cb - Optional callback
 * @returns {module:BuildRunner}
 * @fires module:BuildRunner#4d server not stopped
 */
/**
 * @callback module:BuildRunner~stop4DServerCallback
 * @param {object} error - Error returned by the method
 */
/**
 * Failure event
 *
 * @event module:BuildRunner#4d server not stopped
 * @type {object}
 * @property {object} error - The error
 */
BuildRunner.prototype.stop4DServer = function(reason, cb) {
    if (typeof reason === 'function' &amp;&amp; cb === undefined) {
        cb = reason;
        reason = undefined;
    }
    if (reason !== undefined &amp;&amp; typeof reason !== 'string') {
        throw new TypeError('reason argument must be a string');
    }
    if (cb !== undefined &amp;&amp; typeof cb !== 'function') {
        throw new TypeError('cb argument must be a function');
    }

    var self = this;

    self.killByName('4d server', true, function(err) {
        if (err) {
            if (typeof cb === 'function') {
                cb(err);
            } else {
                self.emit('4d server not stopped', err, reason);
            }
        } else {
            if (typeof cb === 'function') {
                cb(null, reason);
            } else {
                self.emit('4d server stopped', null, reason);
            }
        }
    });

    return this;
};

/** 
 * @function prepareCommand
 * @description Generate the RegExp used to search a process by name according to the given command
 * @param {string|RegExp} command - The command related to the process to lookup (`"wakanda server"`, `"wakanda studio"`, `"wakanda shell"`, `"wakanda controller"`, `"4d server"` or a specific RegExp)
 * @returns {RegExp}
 */
function prepareCommand(command) {
    if (command instanceof RegExp) {
        return command;
    }
    switch (command.toLowerCase()) {
        case 'wakanda server':
            if (config.isWindows()) {
                command = /wakanda[a-z\s]*server\.exe[^\\]*$/i;
            } else if (config.isMac()) {
                command = /wakanda[a-z\s]*server[^\/]*$/i;
            } else {
                command = /wakanda-[a-z]*-?server[^\/]*$/i;
            }
            break;
        case 'wakanda studio':
            if (config.isWindows()) {
                command = /wakanda[a-z\s]*studio\.exe[^\\]*$/i;
            } else if (config.isMac()) {
                command = /wakanda[a-z\s]*studio[^\/]*$/i;
            }
            break;
        case 'wakanda all':
            if (config.isWindows()) {
                command = /wakanda[a-z\s]*(server|studio)\.exe[^\\]*$/i;
            } else if (config.isMac()) {
                command = /wakanda[a-z\s]*(server|studio)[^\/]*$/i;
            } else {
                command = /wakanda-[a-z]*-?server[^\/]*$/i;
            }
            break;
        case '4d server':
            if (config.isWindows()) {
                command = /4d[a-z\s]*server\.exe[^\\]*$/i;
            } else if (config.isMac()) {
                command = /4d[a-z\s]*server[^\/]*$/i;
            }
            break;
    }
    return command;
}

/** 
 * @function module:BuildRunner.getInfoByName
 * @description Get the info (process.pid, process.command, process.arguments) for the process related to the given command.
 * @param {string|RegExp} command - The command related to the process to lookup (`"wakanda server"`, `"wakanda studio"`, `"wakanda shell"`, `"wakanda controller"`, `"4d server"` or a specific RegExp)
 * @param {module:BuildRunner~getInfoByNameCallback} cb - Optional callback
 * @returns {module:BuildRunner}
 * @fires module:BuildRunner#info by name
 * @fires module:BuildRunner#info by name error
 */
/**
 * @callback module:BuildRunner~getInfoByNameCallback
 * @param {object} error - Error returned by the method
 * @param {object} process - Process info (if any), cf. {@link https://github.com/neekey/ps} for details
 */
/**
 * Success event
 *
 * @event module:BuildRunner#info by name
 * @type {object}
 * @property {object} process - Process info (if any), cf. {@link https://github.com/neekey/ps} for details
 */
/**
 * Failure event
 *
 * @event module:BuildRunner#info by name error
 * @type {object}
 * @property {object} error - The error
 */
BuildRunner.prototype.getInfoByName = function(command, cb) {
    if (typeof command !== 'string' &amp;&amp; command instanceof RegExp === false) {
        throw new TypeError('command argument must be a string or a RegExp');
    }
    if (cb !== undefined &amp;&amp; typeof cb !== 'function') {
        throw new TypeError('cb argument must be a function');
    }

    var self = this,
        preparedCommand;

    preparedCommand = prepareCommand(command);

    if (config.isWindows()) {
        ps.lookup({
            command: preparedCommand,
        }, function(err, processes) {
            if (err) {
                if (typeof cb === 'function') {
                    cb(err, preparedCommand);
                } else {
                    self.emit('info by name error', err, command, preparedCommand);
                }
            } else if (processes.length === 0) {
                if (typeof cb === 'function') {
                    cb('process not found', preparedCommand);
                } else {
                    self.emit('info by name error', 'process not found', command, preparedCommand);
                }
            } else {
                if (typeof cb === 'function') {
                    cb(null, processes, preparedCommand);
                } else {
                    self.emit('info by name', processes, command, preparedCommand);
                }
            }
        });
    } else {
        ChildProcess.exec('ps auxwwww', function(err, stdout, stderr) { // oh, those damn spaces...
            var processes = [];
            if (err) {
                if (typeof cb === 'function') {
                    cb(err, preparedCommand);
                } else {
                    self.emit('info by name error', err, command, preparedCommand);
                }
            } else {
                stdout.toString().split(/\r?\n/).forEach(function(item) {
                    if (preparedCommand.test(item) === true) {
                        item = item.split(/\s+/);
                        processes.push({
                            pid: parseInt(item[1]),
                            command: item.slice(10).join(' '),
                            arguments: []
                        });
                    }
                });
                if (processes.length === 0) {
                    if (typeof cb === 'function') {
                        cb('process not found', preparedCommand);
                    } else {
                        self.emit('info by name error', 'process not found', command, preparedCommand);
                    }
                } else {
                    if (typeof cb === 'function') {
                        cb(null, processes, preparedCommand);
                    } else {
                        self.emit('info by name', processes, command, preparedCommand);
                    }
                }
            }
        });
    }

    return this;
};

/** 
 * @function module:BuildRunner.getInfoByPID
 * @description Get the info (process.pid, process.command, process.arguments) for the process related to the given PID.
 * @param {number} pid - The PID related to the process to lookup
 * @param {module:BuildRunner~getInfoByPIDCallback} cb - Optional callback
 * @returns {module:BuildRunner}
 * @fires module:BuildRunner#info by pid
 * @fires module:BuildRunner#info by pid error
 */
/**
 * @callback module:BuildRunner~getInfoByPIDCallback
 * @param {object} error - Error returned by the method
 * @param {object} process - Process info (if any), cf. {@link https://github.com/neekey/ps} for details
 */
/**
 * Success event
 *
 * @event module:BuildRunner#info by pid
 * @type {object}
 * @property {object} process - Process info (if any), cf. {@link https://github.com/neekey/ps} for details
 */
/**
 * Failure event
 *
 * @event module:BuildRunner#info by pid error
 * @type {object}
 * @property {object} error - The error
 */
BuildRunner.prototype.getInfoByPID = function(pid, cb) {
    if (typeof pid !== 'number') {
        throw new TypeError('pid argument must be a number');
    }
    if (cb !== undefined &amp;&amp; typeof cb !== 'function') {
        throw new TypeError('cb argument must be a function');
    }

    var self = this;

    ps.lookup({
        pid: pid,
    }, function(err, processes) {
        if (err) {
            if (typeof cb === 'function') {
                cb(err);
            } else {
                self.emit('info by pid error', err, pid);
            }
        } else if (processes.length === 0) {
            if (typeof cb === 'function') {
                cb('process not found');
            } else {
                self.emit('info by pid error', 'process not found', pid);
            }
        } else {
            if (typeof cb === 'function') {
                cb(null, processes);
            } else {
                self.emit('info by pid', processes, pid);
            }
        }
    });

    return this;
};

/** 
 * @function module:BuildRunner.killAll
 * @description Kill all the known processes.
 * @param {boolean} force - Force kill (default to `false`)
 * @param {module:BuildRunner~killAllCallback} cb - Optional callback
 * @returns {module:BuildRunner}
 * @fires module:BuildRunner#killed all
 */
/**
 * @callback module:BuildRunner~killAllCallback
 * @param {object} error - Error returned by the method
 */
/**
 * Success event
 *
 * @event module:BuildRunner#killed all
 * @type {object}
 */
BuildRunner.prototype.killAll = function(force, cb) {
    if (force === undefined) {
        force = false;
    }
    if (cb === undefined &amp;&amp; force !== undefined &amp;&amp; typeof force === 'function') {
        cb = force;
        force = false;
    }
    if (force !== undefined &amp;&amp; typeof force !== 'boolean') {
        throw new TypeError('force argument must be a boolean');
    }
    if (cb !== undefined &amp;&amp; typeof cb !== 'function') {
        throw new TypeError('cb argument must be a function');
    }

    var self = this,
        commands = ['wakanda server', 'wakanda studio', '4d server'];

    async.eachSeries(
        commands,
        function(command, serieCallback) {
            self.killByName(command, force, function(err) {
                serieCallback();
            });
        },
        function(err) {
            if (typeof cb === 'function') {
                cb();
            } else {
                self.emit('killed all', force);
            }
        }
    );

    return this;
};

/** 
 * @function module:BuildRunner.killByName
 * @description Kill the process related to the given command.
 * @param {string|RegExp} command - The command related to the process to kill (`"wakanda server"`, `"wakanda studio"`, `"wakanda shell"`, `"wakanda controller"`, `"4d server"` or a specific RegExp)
 * @param {boolean} force - Force kill (default to `false`)
 * @param {module:BuildRunner~killByNameCallback} cb - Optional callback
 * @returns {module:BuildRunner}
 * @fires module:BuildRunner#killed by name
 * @fires module:BuildRunner#kill by name error
 */
/**
 * @callback module:BuildRunner~killByNameCallback
 * @param {object} error - Error returned by the method
 */
/**
 * Success event
 *
 * @event module:BuildRunner#killed by name
 * @type {object}
 */
/**
 * Failure event
 *
 * @event module:BuildRunner#kill by name error
 * @type {object}
 * @property {object} error - The error
 */
BuildRunner.prototype.killByName = function(command, force, cb) {
    if (typeof command !== 'string' &amp;&amp; command instanceof RegExp === false) {
        throw new TypeError('command argument must be a string or a RegExp');
    }
    if (force === undefined) {
        force = false;
    }
    if (cb === undefined &amp;&amp; force !== undefined &amp;&amp; typeof force === 'function') {
        cb = force;
        force = false;
    }
    if (force !== undefined &amp;&amp; typeof force !== 'boolean') {
        throw new TypeError('force argument must be a boolean');
    }
    if (cb !== undefined &amp;&amp; typeof cb !== 'function') {
        throw new TypeError('cb argument must be a function');
    }

    var self = this;

    self.getInfoByName(command, function(err, processes) {
        if (err) {
            if (typeof cb === 'function') {
                cb(err);
            } else {
                self.emit('kill by name error', err, command, force);
            }
        } else {
            async.eachSeries(
                processes,
                function(item, serieCallback) {
                    self.killByPID(parseInt(item.pid), force, function(err) {
                        serieCallback();
                    });
                },
                function(err) {
                    if (err) {
                        if (typeof cb === 'function') {
                            cb(err);
                        } else {
                            self.emit('kill by name error', err, command, force);
                        }
                    } else {
                        if (typeof cb === 'function') {
                            cb(null);
                        } else {
                            self.emit('killed by name', processes, command, force);
                        }
                    }
                }
            );
        }
    });

    return this;
};

/** 
 * @function module:BuildRunner.killByPID
 * @description Kill the process related to the given PID.
 * @param {number} pid - The PID related to the process to kill
 * @param {boolean} force - Force kill (default to `false`)
 * @param {module:BuildRunner~killByPIDCallback} cb - Optional callback
 * @returns {module:BuildRunner}
 * @fires module:BuildRunner#killed by pid
 * @fires module:BuildRunner#kill by pid error
 */
/**
 * @callback module:BuildRunner~killByPIDCallback
 * @param {object} error - Error returned by the method
 */
/**
 * Success event
 *
 * @event module:BuildRunner#killed by pid
 * @type {object}
 */
/**
 * Failure event
 *
 * @event module:BuildRunner#kill by pid error
 * @type {object}
 * @property {object} error - The error
 */
BuildRunner.prototype.killByPID = function(pid, force, cb) {
    if (typeof pid !== 'number') {
        throw new TypeError('pid argument must be a number');
    }
    if (force === undefined) {
        force = false;
    }
    if (cb === undefined &amp;&amp; force !== undefined &amp;&amp; typeof force === 'function') {
        cb = force;
        force = false;
    }
    if (force !== undefined &amp;&amp; typeof force !== 'boolean') {
        throw new TypeError('force argument must be a boolean');
    }
    if (cb !== undefined &amp;&amp; typeof cb !== 'function') {
        throw new TypeError('cb argument must be a function');
    }

    var self = this;

    if (pid > 0 &amp;&amp; pid !== process.pid) {
        if (force === false || config.isWindows()) {
            ps.kill(pid, function(err) {
                if (err) {
                    if (typeof cb === 'function') {
                        cb(err);
                    } else {
                        self.emit('kill by pid error', err, pid, force);
                    }
                } else {
                    if (typeof cb === 'function') {
                        cb(null);
                    } else {
                        self.emit('killed by pid', pid, force);
                    }
                }
            });
        } else {
            forceKill(self, pid, cb);
        }
    } else {
        if (typeof cb === 'function') {
            cb('invalid PID: ' + pid);
        } else {
            self.emit('kill by pid error', 'invalid PID: ' + pid, pid, force);
        }
    }

    return this;
};

/** 
 * @function forceKill
 * @description Force kill the process with the given PID.
 * @param {module:BuildRunner} emitter
 * @param {number} pid
 * @param {module:BuildRunner~forceKillCallback} cb
 */
/**
 * @callback module:BuildRunner~forceKillCallback
 * @param {object} error - Error returned by the method
 */
function forceKill(emitter, pid, cb) {
    if (pid > 0 &amp;&amp; pid !== process.pid) {
        ChildProcess.exec('kill -9 ' + pid, function(err, stdout, stderr) {
            if (err || stderr) {
                if (typeof cb === 'function') {
                    cb(err || stderr.toString());
                } else {
                    emitter.emit('kill by pid error', err || stderr.toString(), pid, true);
                }
            } else {
                if (typeof cb === 'function') {
                    cb(null);
                } else {
                    emitter.emit('killed by pid', pid, true);
                }
            }
        });
    } else {
        if (typeof cb === 'function') {
            cb('invalid PID: ' + pid);
        } else {
            emitter.emit('kill by pid error', 'invalid PID: ' + pid, pid, true);
        }
    }
}

module.exports = BuildRunner;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-BuildRetriever.html">BuildRetriever</a></li><li><a href="module-BuildRunner.html">BuildRunner</a></li><li><a href="module-Config.html">Config</a></li><li><a href="module-LicenseUpdater.html">LicenseUpdater</a></li><li><a href="module-QA.html">QA</a></li><li><a href="module-SeleniumProxy.html">SeleniumProxy</a></li><li><a href="module-Synchronizer.html">Synchronizer</a></li><li><a href="module-TestRunner.html">TestRunner</a></li></ul><h3>Global</h3><ul><li><a href="global.html#qaConfig">qaConfig</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.2</a> on Mon Aug 03 2015 12:36:14 GMT+0200 (Paris, Madrid (heure d’été))
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
